(()=>{"use strict";const o=document.getElementById("canvas"),n=o.getContext("webgl"),t=1e-6,e=function(o,n,t){const e=i(o,o.VERTEX_SHADER,"\n    attribute vec4 a_Position;\n    void main() {\n        gl_Position = a_Position;\n    }\n"),r=i(o,o.FRAGMENT_SHADER,"\n    precision mediump float;\n    uniform vec3 my_color;\n    void main() {\n        gl_FragColor.rgb = my_color;\n        gl_FragColor.a = 1.0;\n    }\n");if(!e||!r)return null;const l=o.createProgram();if(!l)return console.log("unable to create program"),null;o.attachShader(l,e),o.attachShader(l,r),o.linkProgram(l);if(!o.getProgramParameter(l,o.LINK_STATUS)){const n=o.getProgramInfoLog(l);return console.log("Failed to link program: "+n),o.deleteProgram(l),o.deleteShader(r),o.deleteShader(e),null}return l}(n);e||console.log("Failed to create program"),n.useProgram(e);const r=n.getAttribLocation(e,"a_Position");n.enableVertexAttribArray(r);const l=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,l);const c=n.FLOAT;n.vertexAttribPointer(r,2,c,!1,0,0);const s=n.getUniformLocation(e,"my_color");function i(o,n,t){const e=o.createShader(n);if(null===e)return console.log("unable to create shader"),null;if(o.shaderSource(e,t),o.compileShader(e),!o.getShaderParameter(e,o.COMPILE_STATUS)){const n=o.getShaderInfoLog(e);return console.log("Failed to compile shader: "+n),o.deleteShader(e),null}return e}function a(o){const t=[];o.forEach((o=>{t.push(o.x,o.y)}));const e=new Float32Array(t);n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW);const r=n.LINE_LOOP,l=e.length/2;n.drawArrays(r,0,l)}class u{constructor(o,n){this.x=0,this.y=0,this.x=o,this.y=n}same(o){return Math.abs(this.x-o.x)<t&&Math.abs(this.y-o.y)<t}copy(){return new u(this.x,this.y)}toString(){return`(${this.x}, ${this.y})`}}class p{constructor(o,n){this.p1=o,this.p2=n}copy(){return new p(this.p1,this.p2)}}function g(o,n){const t=o.p1,e=o.p2,r=n;return(e.x-t.x)*(r.y-t.y)-(r.x-t.x)*(e.y-t.y)}class h{constructor(o){this.points=[],o.forEach((o=>{this.points.push(new u(o.x,o.y))}))}getedges(){const o=[];for(let n=0;n<this.points.length;n++){const t=this.points[n],e=this.points[(n+1)%this.points.length];o.push(new p(t,e))}return o}copy(){return new h(this.points)}}class f{constructor(){this.loops=[]}add_loop(o){this.loops.push(o.copy())}}const d=new f,y=new f,m=new f,E=document.getElementById("main-polygon-button"),x=document.getElementById("clip-polygon-button"),_=document.getElementById("clip-button"),A=document.getElementById("clear-button"),P=document.getElementById("state-text");function w(o,n){const e=[];return o.getedges().forEach((o=>{const r=[];n.loops.forEach((n=>{n.getedges().forEach((n=>{const e=function(o,n){if(g(o,n.p1)*g(o,n.p2)>=-t)return null;const e=g(n,o.p1),r=g(n,o.p2);if(e*r>=-t)return null;const l=e/(e-r),c=o.p1.x+(o.p2.x-o.p1.x)*l,s=o.p1.y+(o.p2.y-o.p1.y)*l;return new u(c,s)}(o,n);null!==e&&r.push(e)}))})),r.sort(((n,t)=>(n.x-o.p1.x)*(n.x-o.p1.x)+(n.y-o.p1.y)*(n.y-o.p1.y)-((t.x-o.p1.x)*(t.x-o.p1.x)+(t.y-o.p1.y)*(t.y-o.p1.y)))),e.push(o.p1.copy()),e.push(...r)})),e}function S(o,n){for(const[t,e]of n){const n=R(o,e);if(-1!==n)return[t,n,e]}return[null,-1,[]]}function R(o,n){for(let t=0;t<n.length;t++)if(n[t].same(o))return t;return-1}function b(o,n){for(const t of n)if(t.same(o))return!0;return!1}function F(o,n,t){for(const[e,r]of o)for(let o=0;o<r.length;o++){const e=r[o];if(b(e,t))continue;const[l,c]=S(e,n);if(null!==l&&-1!==c)return e}return null}var L;!function(o){o[o.MainPolygon=0]="MainPolygon",o[o.ClipPolygon=1]="ClipPolygon"}(L||(L={}));let v=L.MainPolygon;const I=[];function M(o,t,e){n.uniform3f(s,o,t,e)}function T(){n.clearColor(1,1,1,1),n.clear(n.COLOR_BUFFER_BIT),M(1,0,0),console.log("main_polygon",d),d.loops.forEach((o=>{a(o.points)})),M(0,0,1),console.log("clip_polygon",y),y.loops.forEach((o=>{a(o.points)})),M(0,1,1),console.log("clipped_polygon",m),m.loops.forEach((o=>{a(o.points)})),v===L.MainPolygon?M(1,0,0):M(0,0,1),console.log("current_points",I),I.forEach((o=>{!function(o,t,e=.01){const r=[o,t];for(let n=0;n<=100;n++){const l=2*Math.PI/100*n,c=o+e*Math.cos(l),s=t+e*Math.sin(l);r.push(c,s)}const l=new Float32Array(r);n.bufferData(n.ARRAY_BUFFER,l,n.STATIC_DRAW);const c=n.TRIANGLE_FAN,s=l.length/2;n.drawArrays(c,0,s)}(o.x,o.y)}))}E.addEventListener("click",(o=>{I.length>0?alert("请先绘制当前多边形"):(v=L.MainPolygon,P.innerText="输入主多边形")})),x.addEventListener("click",(o=>{I.length>0?alert("请先绘制当前多边形"):(v=L.ClipPolygon,P.innerText="输入裁剪多边形")})),A.addEventListener("click",(o=>{console.log("clear"),d.loops.length=0,y.loops.length=0,m.loops.length=0,I.length=0,v=L.MainPolygon,P.innerText="输入主多边形",T()})),_.addEventListener("click",(o=>{console.log("clip"),function(o,n){const t=new Map,e=new Map;o.loops.forEach((o=>{t.set(o,w(o,n))})),n.loops.forEach((n=>{e.set(n,w(n,o))})),console.log("m_points",t),console.log("c_points",e);const r=[];let l=F(t,e,r);if(null===l)return void alert("没有交点");const c=[],s=[];for(;!b(l,r)||(l=F(t,e,r),console.log("find loop",s.toString()),c.push([]),s.forEach((o=>{c[c.length-1].push(o.copy())})),s.length=0,null!==l);){const[o,n,c]=S(l,t),[i,a,u]=S(l,e);if(s.push(l.copy()),r.push(l.copy()),null===o){l=u[(a+1)%u.length];continue}if(null===i){l=c[(n+1)%c.length];continue}const h=c[(n+1)%c.length],f=u[(a+1)%u.length];l=g(new p(l,h),f)<0?h.copy():f.copy()}m.loops.length=0,c.forEach((o=>{m.add_loop(new h(o))}))}(d,y),T()})),o.addEventListener("click",(n=>{const[t,e]=function(n,t){const e=o.getBoundingClientRect(),r=o.width,l=o.height;return[(n-e.left)/r*2-1,(t-e.top)/l*-2+1]}(n.clientX,n.clientY);console.log("left click"),I.push(new u(t,e)),T()})),o.addEventListener("contextmenu",(o=>{if(console.log("right click"),o.preventDefault(),I.length<3)return void alert("至少需要三个点");const n=new h(I);v===L.MainPolygon?d.add_loop(n):y.add_loop(n),I.length=0,T()}))})();